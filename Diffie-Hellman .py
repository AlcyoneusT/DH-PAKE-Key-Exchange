import random
import os
import hmac
from hashlib import sha256

# Author: Ziyuan Wang
# Version: 1.3 (enhanced with random salt and HMAC-based MAC)

# ============================================================================
# Global parameters for Diffie-Hellman key exchange
# Note: In real-world applications, use a large (2048+ bit) prime p and a suitable generator g.
# Here we keep small values for demonstration and readability.
p = 23  # Example small prime (for demonstration only)
g = 5   # Example generator (for demonstration only)

# ----------------------------------------------------------------------------
# Function: generate_private_key
# Purpose : Generate a random private key in the range [1, p-2]
# Input   : p (prime modulus)
# Output  : random integer serving as the private key
# ----------------------------------------------------------------------------
def generate_private_key(p):
    """
    Generates a random private key within the range [1, p-2].
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: A random private key.
    """
    return random.randint(1, p - 2)

# ----------------------------------------------------------------------------
# Function: generate_public_key
# Purpose : Compute public key from private key, generator, and modulus
# Formula : public_key = g^private_key mod p
# Inputs  : private_key (int), g (generator), p (prime modulus)
# Output  : public_key (int)
# ----------------------------------------------------------------------------
def generate_public_key(private_key, g, p):
    """
    Generates the public key using the private key, generator g, and prime p.
    Public key = g^private_key mod p
    :param private_key: The private key generated by the user.
    :param g: The generator for Diffie-Hellman.
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: The public key.
    """
    return pow(g, private_key, p)

# ----------------------------------------------------------------------------
# Function: compute_shared_secret
# Purpose : Derive shared secret using the other party's public key
# Formula : shared_secret = their_public_key^your_private_key mod p
# Inputs  : their_public_key (int), your_private_key (int), p (prime modulus)
# Output  : shared_secret (int)
# ----------------------------------------------------------------------------
def compute_shared_secret(their_public_key, your_private_key, p):
    """
    Computes the shared secret using the other party's public key and your private key.
    Shared Secret = (their_public_key)^your_private_key mod p
    :param their_public_key: The public key received from the other party.
    :param your_private_key: The private key generated by the user.
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: The shared secret.
    """
    return pow(their_public_key, your_private_key, p)

# ============================================================================
# Password-Authenticated Key Exchange (PAKE) helpers

# ----------------------------------------------------------------------------
# Generate a cryptographically secure random salt (hex-encoded)
# Salt adds randomness to password hashing, preventing rainbow table attacks.
# Salt should be stored or transmitted alongside the hash.
salt = os.urandom(16).hex()  # 16 random bytes -> 32-character hex string

# ----------------------------------------------------------------------------
# Function: generate_password_hash
# Purpose : Hash a password combined with a salt using SHA-256
# Inputs  : password (str), salt (str, hex-encoded random value)
# Output  : integer representation of the hash (for modular operations)
# ----------------------------------------------------------------------------
def generate_password_hash(password, salt):
    """
    Generates a hash of the password combined with a salt using SHA-256.
    :param password: The shared password between Theo and Knew.
    :param salt: A salt value to add randomness to the password hash.
    :return: A hashed value derived from the password and salt.
    """
    hash_bytes = sha256((password + salt).encode()).hexdigest()
    return int(hash_bytes, 16)

# ----------------------------------------------------------------------------
# Function: combine_with_password
# Purpose : Combine shared secret and password hash into a final authenticated key
# Method  : (shared_secret + password_hash) mod p, then hash result with SHA-256
# Inputs  : shared_secret (int), password_hash (int)
# Output  : hex-encoded SHA-256 digest (str)
# ----------------------------------------------------------------------------
def combine_with_password(shared_secret, password_hash):
    """
    Combines the shared secret with the password hash to generate a final authenticated key.
    The combination is done using modular addition followed by hashing.
    :param shared_secret: The shared secret established through Diffie-Hellman.
    :param password_hash: The hash of the shared password.
    :return: The final combined key as a SHA-256 hash.
    """
    combined_value = (shared_secret + password_hash) % p
    return sha256(str(combined_value).encode()).hexdigest()

# ============================================================================
# Message Authentication Code (MAC) functions using HMAC-SHA256

# ----------------------------------------------------------------------------
# Function: generate_mac
# Purpose : Create a message authentication code (MAC) for integrity and authenticity
# Method  : HMAC with shared key and SHA-256
# Inputs  : message (str), key (str, final authenticated secret)
# Output  : hex-encoded HMAC-SHA256 digest (str)
# ----------------------------------------------------------------------------
def generate_mac(message, key):
    """
    Generates a MAC for a given message using HMAC-SHA256.
    :param message: The message to be authenticated.
    :param key: The shared key used to generate the MAC.
    :return: The generated MAC.
    """
    return hmac.new(key.encode(), message.encode(), sha256).hexdigest()

# ----------------------------------------------------------------------------
# Function: verify_mac
# Purpose : Verify that a received MAC matches the computed HMAC
# Inputs  : received_message (str), received_mac (str), key (str)
# Output  : True if valid, False otherwise
# ----------------------------------------------------------------------------
def verify_mac(received_message, received_mac, key):
    """
    Verifies the MAC of a received message.
    :param received_message: The received message.
    :param received_mac: The received MAC.
    :param key: The shared key used to verify the MAC.
    :return: True if MAC is valid, False otherwise.
    """
    expected_mac = generate_mac(received_message, key)
    return hmac.compare_digest(expected_mac, received_mac)

# ============================================================================
# Example Workflow: Theo <-> Knew

# Step 1: Theo and Knew generate their private keys
theo_private_key = generate_private_key(p)
knew_private_key = generate_private_key(p)

# Step 2: Theo and Knew generate their public keys
theo_public_key = generate_public_key(theo_private_key, g, p)
knew_public_key = generate_public_key(knew_private_key, g, p)

# Step 3: Theo and Knew exchange public keys and compute the shared secret
theo_shared_secret = compute_shared_secret(knew_public_key, theo_private_key, p)
knew_shared_secret = compute_shared_secret(theo_public_key, knew_private_key, p)

# Step 4: Verify that both shared secrets are identical
assert theo_shared_secret == knew_shared_secret, "Shared secrets do not match!"
print("Shared secret successfully established.")
print(f"Theo's shared secret: {theo_shared_secret}")
print(f"Knew's shared secret: {knew_shared_secret}")

# Step 5: PAKE - derive final authenticated key using shared password
shared_password = "securepassword123"
password_hash = generate_password_hash(shared_password, salt)

theo_final_secret = combine_with_password(theo_shared_secret, password_hash)
knew_final_secret = combine_with_password(knew_shared_secret, password_hash)

# Step 6: Verify that both final secrets match
assert theo_final_secret == knew_final_secret, "Final authenticated secrets do not match!"
print("Password-authenticated shared secret successfully established.")
print(f"Random salt used (hex): {salt}")
print(f"Theo's final secret: {theo_final_secret}")
print(f"Knew's final secret: {knew_final_secret}")

# Step 7: Use the final authenticated key to generate and verify a MAC for a message
message = "This is a secure message."
mac = generate_mac(message, theo_final_secret)
print(f"Generated MAC: {mac}")

# Simulate sending the message and MAC to Knew
received_message = message
received_mac = mac

# Step 8: Knew verifies the MAC
if verify_mac(received_message, received_mac, knew_final_secret):
    print("Message is verified and intact.")
else:
    print("Message verification failed! Possible tampering detected.")